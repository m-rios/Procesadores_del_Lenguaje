package semantico;
import java_cup.runtime.*;
import java.io.*;
import java.util.Stack;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Hashtable;

/*User code*/

parser code {:
	public void syntax_error(Symbol cur_token){
		report_error("Error sintactico", cur_token);
	}
	public void report_error(String message, Object info) {
       	StringBuffer m = new StringBuffer(message);
       	String token = "";
		if(info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s=((java_cup.runtime.Symbol)info);
			if(s.left >= 0) {
				m.append(" en linea "+(s.left+1));
			}
			token = (String) "'"+s.value+"'";
		}
		m.append(": "+token);
		System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) {
       	report_error(message, info);
		System.exit(1);
    }
:}

action code {:

	private Hashtable registros = new Hashtable();

	public void error_semantico(String msg, int line){
		System.err.println("ERROR SEMANTICO en linea "+line+": "+msg);
	}
:}

/* Preliminaries to set up and use the scanner.  */
// init with {: scanner.init();              :};
// scan with {: return scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            ADESCR, CDESCR, AIDENT, CIDENT, ADATE, CDATE;
terminal 			ASTORAGE, CSTORAGE, AREGISTER, CREGISTER, ANAME, CNAME;
terminal 			AUSE, CUSE, ABITSIZE, CBITSIZE, AREGBITCODE;
terminal 			CREGBITCODE, AGROUP, AREGISTERS, CREGISTERS;
terminal 			CGROUP, AUPD, CUPD, COMA;

terminal String 	TEXT, DATE, NAME, USE, REGBITCODE;
terminal int 		BITSIZE;


terminal 			AINSNS, CINSNS, AOPCODE, COPCODE, AINSBITCODE;
terminal 			CINSBITCODE, INSBITCODE, ABEHAV, CBEHAV, CIN, COUT, AOUT;
terminal 			ACORCHETE, CCORCHETE, AIN, IN;
terminal 			AINS, CINS;



/* Non terminals */
non terminal 		especificacion, bloque_descripcion, identificacion, fecha;

non terminal 		bloque_almacenamiento, registro, grupo;

non terminal 		bloque_instrucciones, instruccion, entrada;
non terminal 		salida, in, bloque_in;
non terminal Stack	behav, insbitcode, instrucciones, registros_aux, registros;
non terminal Stack	use, sub_registros, grupos;
non terminal String	regbitcode;
non terminal storeClass	contenido_registro;

/* Precedences */
// precedence left PLUS, MINUS;


/* The grammar */
especificacion ::= 	|AUPD bloque_descripcion:descr bloque_almacenamiento:store 
					bloque_instrucciones:ins CUPD
					{:	if (descr == null) {
							descr = "N/A\n";
						} 
						if (store== null) {
							store = "N/A\n";
						}
						if (ins== null) {
							ins = "N/A\n";
						}
						String text = 	"------------------------\n"+
										"Descripcion:\n"+
										"------------------------\n"+
										descr+
										"------------------------\n"+
										"Almacenamiento:\n"+
										"------------------------\n"+
										store.toString()+
										"------------------------\n"+
										"Instrucciones:\n"+
										"------------------------\n"+
										ins.toString();
						System.out.println(text);:}
					| error
					;
//se acepta fichero vacío como válido

/*gramatica bloque descripción*/
bloque_descripcion ::= 	ADESCR identificacion:id fecha:date CDESCR 
						{:RESULT = "ident: "+id+"\n date: "+date+"\n";:}
						| error 
						;

identificacion ::= 	AIDENT TEXT:id CIDENT {:RESULT = id;:}
					;

fecha ::= 	|ADATE DATE:d CDATE 
					{:	
					try{
						DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
					    formatter.setLenient(false);
					    formatter.parse(d);
					    RESULT = d;
					}catch(ParseException e) { 
					    System.out.println("Warning: Date format incorrect");
					    RESULT = "Date Wrong";
					}
					:}
			;

/*gramática bloque almacenamiento*/
bloque_almacenamiento ::= 	ASTORAGE registros:r grupos:g CSTORAGE 
									{:	Stack stack = new Stack();
										stack.push(r);
										stack.push(g);
										RESULT = stack;
										:}
							| ASTORAGE registros:r CSTORAGE 
									{:	Stack stack = new Stack();
										stack.push(r);
										RESULT = stack;
										:}
							| error 
							;

registros ::= registros:rs registro:r {:	rs.push(r);
											RESULT = rs;	:}
			| registro:r {:	Stack stack = new Stack();
							stack.push(r);
							RESULT = stack;
							:}
			;
grupos ::= 	grupos:gs grupo:g {:	gs.push(g);
									RESULT = gs;	:}
			| grupo:g {:	Stack stack = new Stack();
							stack.push(g);
							RESULT = stack;	:}
			;

registro ::= AREGISTER contenido_registro:c CREGISTER {:	c.setRegister();
															if (registros.containsKey(c.getRegName())) {
																error_semantico("Registro "+c.getRegName()+" ya existe",cright);
															} else {
																registros.put(c.getRegName(),c.getUse());
															}
															RESULT = c;:};

contenido_registro ::= 	ANAME NAME:n CNAME AUSE use:u CUSE ABITSIZE BITSIZE:b 
						CBITSIZE regbitcode:r {:
								if ((u.search("\"ProgramPC\"") != -1 || u.search("\"FlagVector\"") != -1) && u.size() > 1) {
									error_semantico("Usos de registro incompatibles",uright+1);
								}	
								storeClass sc = new storeClass(n,u,b,r);
								RESULT = sc;
								:}
						;

use ::=	use:us COMA USE:u {:	
								us.push(u);
								RESULT = us;:}
		| USE:u {:	Stack stack = new Stack();
					stack.push(u);
					RESULT = stack;:}
		;

regbitcode ::=	|AREGBITCODE REGBITCODE:r CREGBITCODE {:RESULT = r;:}
				;

grupo ::= 	AGROUP contenido_registro:c AREGISTERS sub_registros:r CREGISTERS CGROUP
			{:	c.setRegistros(r);
				c.setGroup();
				registros.put(c.getRegName(),c.getUse());
				RESULT = c;:}
			;

sub_registros ::=  	registros_aux:r NAME:n {:	r.push(n);
												if (!registros.containsKey(n)) {
													error_semantico("Registro "+n+" no existe",nright+1);
												}
											RESULT = r; :}
				;
registros_aux ::= 	registros_aux:r NAME:n COMA {:	r.push(n);
													if (!registros.containsKey(n)) {
														error_semantico("Registro "+n+" no existe",nright+1);
													}
													RESULT = r;:}
					| NAME:n COMA {:	Stack stack = new Stack();
										stack.push(n);
										if (!registros.containsKey(n)) {
											error_semantico("Registro "+n+" no existe",nright+1);
										}
										RESULT = stack;:}
					;

/*gramática bloque instrucciones*/
bloque_instrucciones ::= 	AINSNS instrucciones:i CINSNS {:RESULT = i;:}
							| error
							;

instrucciones ::= instrucciones:ins instruccion:in {:	ins.push(in);
														RESULT = ins;:}
				| instruccion:i {:	Stack ins = new Stack();
									ins.push(i);
									RESULT = ins;
									:}
				;

instruccion ::= AINS AOPCODE TEXT:op COPCODE entrada salida AINSBITCODE 
				insbitcode:ins CINSBITCODE ABEHAV behav:be CBEHAV CINS
				{:	insClass instruction = new insClass(op,ins,be);
					RESULT = instruction;:}
				;

insbitcode ::= insbitcode:ins COMA INSBITCODE:i {:	ins.push(i);
													RESULT = ins;
													:}
				| INSBITCODE:i {:	Stack s = new Stack();
								s.push(i);
								RESULT = s;
								:}
				;

/*entradas / salidas*/
entrada ::= | AIN bloque_in CIN
			;

bloque_in ::= 	bloque_in COMA ACORCHETE in CCORCHETE
				| ACORCHETE in CCORCHETE
				;
in ::= 	in COMA IN
		| IN
		| in COMA NAME
		| NAME
		;

salida ::= |AOUT ACORCHETE NAME:n CCORCHETE COUT {:
													if (registros.containsKey(n)) {
														Stack s = (Stack) registros.get(n);	
														if (s.contains("\"FlagVector\"")) {
															error_semantico("El registro de destino no puede ser de tipo FlagVector",nright+1);
														}
													}else{
														error_semantico("El registro "+n+" no existe",nright+1);
													}
													
	:};

/*comportamiento*/
behav ::= behav:be COMA ACORCHETE TEXT:b CCORCHETE {:	be.push(b);
														RESULT = be; :}
		| ACORCHETE TEXT:b CCORCHETE {:	Stack stack = new Stack();
										stack.push(b);
										RESULT = stack;:}
		;